#!/usr/bin/env bash
# task-status: Statusline integration script for Claude Task System
# Displays task context information for terminal prompts

set -euo pipefail

# Configuration flags (set by argument parsing)
USE_ICONS=true
SHOW_ORIGIN=false
SHOW_TASK=false
SHOW_COUNTS=false
SHOW_ALL=true

# Context variables (populated from CLAUDE_ENV_FILE)
TASK_CONTEXT=""
CURRENT_TASK_ID=""

# Icon definitions - Origin
readonly ICON_MAIN="⎇"
readonly ICON_WORKTREE="⌂"
readonly ASCII_MAIN="[M]"
readonly ASCII_WORKTREE="[W]"

# Icon definitions - Task types
readonly ICON_FEATURE="✦"
readonly ICON_BUGFIX="●"
readonly ICON_REFACTOR="⟳"
readonly ICON_PERFORMANCE="⚡"
readonly ICON_DEPLOYMENT="▲"
readonly ICON_UNKNOWN="◆"
readonly ASCII_FEATURE="[feat]"
readonly ASCII_BUGFIX="[bug]"
readonly ASCII_REFACTOR="[refactor]"
readonly ASCII_PERFORMANCE="[perf]"
readonly ASCII_DEPLOYMENT="[deploy]"
readonly ASCII_UNKNOWN="[?]"

# Parsed task data (populated by parse_task_md)
TASK_TITLE=""
TASK_TYPE=""
TASK_FEATURE=""
show_help() {
    cat << 'EOF'
Usage: task-status [OPTIONS]

Display Claude Task System context information for terminal statuslines.

Options:
  --help        Show this help message and exit
  --no-icons    Use ASCII characters instead of Unicode icons
  --origin      Show only the origin indicator (main repo vs worktree)
  --task        Show only the current task info (title, type, feature)
  --counts      Show only task counts

If no section flags are specified, all sections are shown.

Environment:
  CLAUDE_ENV_FILE    Path to environment file with pre-detected context variables.
                     Expected variables: TASK_CONTEXT, CURRENT_TASK_ID

Examples:
  task-status                    # Show all sections with icons
  task-status --no-icons         # Show all sections with ASCII
  task-status --origin           # Show only origin indicator
  task-status --origin --task    # Show origin and task sections

Exit codes:
  0    Success
  1    Invalid arguments
EOF
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help)
                show_help
                exit 0
                ;;
            --no-icons)
                USE_ICONS=false
                shift
                ;;
            --origin)
                SHOW_ORIGIN=true
                SHOW_ALL=false
                shift
                ;;
            --task)
                SHOW_TASK=true
                SHOW_ALL=false
                shift
                ;;
            --counts)
                SHOW_COUNTS=true
                SHOW_ALL=false
                shift
                ;;
            *)
                echo "Unknown option: $1" >&2
                echo "Use --help for usage information" >&2
                exit 1
                ;;
        esac
    done

    # If no section flags specified, show all
    if [[ "$SHOW_ALL" == "true" ]]; then
        SHOW_ORIGIN=true
        SHOW_TASK=true
        SHOW_COUNTS=true
    fi
}

load_environment() {
    # Only use values from CLAUDE_ENV_FILE, not inherited environment
    TASK_CONTEXT=""
    CURRENT_TASK_ID=""

    if [[ -n "${CLAUDE_ENV_FILE:-}" && -f "$CLAUDE_ENV_FILE" && -r "$CLAUDE_ENV_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$CLAUDE_ENV_FILE" 2>/dev/null || true
    fi
}

# Get indicator for context type
# Args: $1 = context ("main" or "worktree")
get_indicator() {
    local context="$1"
    if [[ "$context" == "worktree" ]]; then
        [[ "$USE_ICONS" == "true" ]] && echo -n "$ICON_WORKTREE" || echo -n "$ASCII_WORKTREE"
    else
        [[ "$USE_ICONS" == "true" ]] && echo -n "$ICON_MAIN" || echo -n "$ASCII_MAIN"
    fi
}

# Get icon for task type
# Args: $1 = type (feature|bugfix|refactor|performance|deployment)
get_type_icon() {
    local type="$1"
    # Normalize: lowercase and trim whitespace using bash parameter expansion
    type="${type,,}"              # lowercase
    type="${type#"${type%%[![:space:]]*}"}"  # trim leading
    type="${type%"${type##*[![:space:]]}"}"  # trim trailing

    local icon ascii
    case "$type" in
        feature)     icon="$ICON_FEATURE";     ascii="$ASCII_FEATURE" ;;
        bugfix)      icon="$ICON_BUGFIX";      ascii="$ASCII_BUGFIX" ;;
        refactor)    icon="$ICON_REFACTOR";    ascii="$ASCII_REFACTOR" ;;
        performance) icon="$ICON_PERFORMANCE"; ascii="$ASCII_PERFORMANCE" ;;
        deployment)  icon="$ICON_DEPLOYMENT";  ascii="$ASCII_DEPLOYMENT" ;;
        *)           icon="$ICON_UNKNOWN";     ascii="$ASCII_UNKNOWN" ;;
    esac

    [[ "$USE_ICONS" == "true" ]] && echo -n "$icon" || echo -n "$ascii"
}

# Parse task.md file and populate TASK_TITLE, TASK_TYPE, TASK_FEATURE
# Uses CURRENT_TASK_ID and CLAUDE_SPAWN_DIR to locate task.md
parse_task_md() {
    TASK_TITLE=""
    TASK_TYPE=""
    TASK_FEATURE=""

    # Need task ID to locate file
    if [[ -z "$CURRENT_TASK_ID" ]]; then
        return 0
    fi

    # Construct path to task.md
    local spawn_dir="${CLAUDE_SPAWN_DIR:-.}"
    local task_file="$spawn_dir/task-system/task-$CURRENT_TASK_ID/task.md"

    # Check if file exists and is readable
    if [[ ! -f "$task_file" || ! -r "$task_file" ]]; then
        return 0
    fi

    # Read file content (limit to first 100 lines for performance)
    local content
    content=$(head -n 100 "$task_file" 2>/dev/null) || return 0

    # Extract task title from "# Task NNN: Title" header
    # Match first line starting with "# Task" and extract everything after first colon
    local title_line
    title_line=$(echo "$content" | grep -m1 "^# Task [0-9]*:" 2>/dev/null) || true
    if [[ -n "$title_line" ]]; then
        # Extract everything after first colon, trim whitespace
        TASK_TITLE=$(echo "$title_line" | sed 's/^# Task [0-9]*:[[:space:]]*//')
        # Truncate to 40 chars if too long
        if [[ ${#TASK_TITLE} -gt 40 ]]; then
            TASK_TITLE="${TASK_TITLE:0:37}..."
        fi
    fi

    # Extract task type from "## Task Type" section
    # Look for line after "## Task Type" that contains the type keyword
    local in_type_section=false
    while IFS= read -r line; do
        if [[ "$line" =~ ^##[[:space:]]+Task[[:space:]]+Type ]]; then
            in_type_section=true
            continue
        fi
        if [[ "$in_type_section" == "true" ]]; then
            # Skip empty lines
            if [[ -z "$line" || "$line" =~ ^[[:space:]]*$ ]]; then
                continue
            fi
            # Check if we hit another section
            if [[ "$line" =~ ^## ]]; then
                break
            fi
            # Extract the type keyword (first word before " - " or end of line)
            local type_word
            type_word=$(echo "$line" | sed 's/^[[:space:]]*//' | cut -d' ' -f1 | tr -d '-')
            if [[ -n "$type_word" ]]; then
                TASK_TYPE="$type_word"
                break
            fi
        fi
    done <<< "$content"

    # Extract feature reference from "## Feature Context" section
    # Look for "**Feature**:" line and extract feature name from link
    local feature_line
    feature_line=$(echo "$content" | grep -m1 '\*\*Feature\*\*:' 2>/dev/null) || true
    if [[ -n "$feature_line" ]]; then
        # Extract from markdown link format: [NNN-feature-name](path)
        # Get text between [ and ]
        local feature_ref
        feature_ref=$(echo "$feature_line" | sed -n 's/.*\[\([^]]*\)\].*/\1/p')
        if [[ -n "$feature_ref" ]]; then
            # Remove leading numbers and dash (e.g., "001-" from "001-user-auth")
            TASK_FEATURE=$(echo "$feature_ref" | sed 's/^[0-9]*-//')
        fi
    fi
}

# Format the task section output
# Returns: "Title type_icon feature_name" or "--" if no task info
format_task_section() {
    local -a parts=()

    # If no task info available, return "--"
    if [[ -z "$TASK_TITLE" && -z "$TASK_TYPE" && -z "$TASK_FEATURE" ]]; then
        echo -n "--"
        return
    fi

    # Add title if available
    if [[ -n "$TASK_TITLE" ]]; then
        parts+=("$TASK_TITLE")
    fi

    # Add type icon if available
    if [[ -n "$TASK_TYPE" ]]; then
        parts+=("$(get_type_icon "$TASK_TYPE")")
    fi

    # Add feature name if available
    if [[ -n "$TASK_FEATURE" ]]; then
        parts+=("$TASK_FEATURE")
    fi

    # Join with spaces
    local IFS=' '
    echo -n "${parts[*]}"
}
build_output() {
    local -a parts=()

    if [[ "$SHOW_ORIGIN" == "true" ]]; then
        parts+=("$(get_indicator "${TASK_CONTEXT:-main}")")
    fi

    if [[ "$SHOW_TASK" == "true" ]]; then
        local task_section
        task_section=$(format_task_section)
        if [[ -n "$task_section" ]]; then
            parts+=("$task_section")
        fi
    fi

    # SHOW_COUNTS placeholder - will be implemented in future tasks

    # Join parts with space separator
    local IFS=' '
    echo "${parts[*]}"
}

main() {
    parse_args "$@"
    load_environment
    parse_task_md
    build_output
}

main "$@"
