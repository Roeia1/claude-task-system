#!/usr/bin/env bash
# task-status: Statusline integration script for Claude Task System
# Displays task context information for terminal prompts with powerline formatting

set -euo pipefail

# Configuration flags (set by argument parsing)
USE_ICONS=true
SHOW_ORIGIN=false
SHOW_TASK=false
SHOW_COUNTS=false
SHOW_ALL=true

# Context variables (populated from CLAUDE_ENV_FILE)
TASK_CONTEXT=""
CURRENT_TASK_ID=""
CLAUDE_SPAWN_DIR=""

# Icon definitions
readonly ICON_MAIN="‚éá"
readonly ICON_WORKTREE="‚åÇ"
readonly ASCII_MAIN="[M]"
readonly ASCII_WORKTREE="[W]"

# Task count icons
readonly ICON_IN_PROGRESS="‚óè"
readonly ICON_PENDING="‚óê"
readonly ICON_REMOTE="‚óã"
readonly ASCII_IN_PROGRESS="I:"
readonly ASCII_PENDING="P:"
readonly ASCII_REMOTE="R:"

# Feature count icons
readonly ICON_FEATURE_ACTIVE="‚ó®"
readonly ICON_FEATURE_DRAFT="‚óß"
readonly ASCII_FEATURE_ACTIVE="A:"
readonly ASCII_FEATURE_DRAFT="D:"

# ANSI color codes for dark theme (256-color mode)
readonly BG_BLUE=$'\x1b[48;5;25m'       # Main origin background (#3465a4)
readonly BG_CYAN=$'\x1b[48;5;30m'       # Worktree origin background (#06989a)
readonly BG_GRAY=$'\x1b[48;5;240m'      # Task info background (#555753)
readonly BG_DARK_GRAY=$'\x1b[48;5;235m' # Counts background (#2e3436)

# Foreground colors
readonly FG_WHITE=$'\x1b[38;5;15m'
readonly FG_BLACK=$'\x1b[38;5;0m'
readonly FG_LIGHT_GRAY=$'\x1b[38;5;250m'

# Powerline separator (U+E0B0)
readonly SEPARATOR=$'\ue0b0'
readonly RESET=$'\x1b[0m'

show_help() {
    cat << 'EOF'
Usage: task-status [OPTIONS]

Display Claude Task System context information for terminal statuslines.

Options:
  --help        Show this help message and exit
  --no-icons    Use ASCII characters instead of Unicode icons
  --origin      Show only the origin indicator (main repo vs worktree)
  --task        Show only the current task ID
  --counts      Show only task counts

If no section flags are specified, all sections are shown.

Environment:
  CLAUDE_ENV_FILE    Path to environment file with pre-detected context variables.
                     Expected variables: TASK_CONTEXT, CURRENT_TASK_ID, CLAUDE_SPAWN_DIR

Examples:
  task-status                    # Show all sections with icons
  task-status --no-icons         # Show all sections with ASCII
  task-status --origin           # Show only origin indicator
  task-status --origin --task    # Show origin and task sections

Exit codes:
  0    Success
  1    Invalid arguments
EOF
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help)
                show_help
                exit 0
                ;;
            --no-icons)
                USE_ICONS=false
                shift
                ;;
            --origin)
                SHOW_ORIGIN=true
                SHOW_ALL=false
                shift
                ;;
            --task)
                SHOW_TASK=true
                SHOW_ALL=false
                shift
                ;;
            --counts)
                SHOW_COUNTS=true
                SHOW_ALL=false
                shift
                ;;
            *)
                echo "Unknown option: $1" >&2
                echo "Use --help for usage information" >&2
                exit 1
                ;;
        esac
    done

    # If no section flags specified, show all
    if [[ "$SHOW_ALL" == "true" ]]; then
        SHOW_ORIGIN=true
        SHOW_TASK=true
        SHOW_COUNTS=true
    fi
}

load_environment() {
    # Only use values from CLAUDE_ENV_FILE, not inherited environment
    TASK_CONTEXT=""
    CURRENT_TASK_ID=""
    CLAUDE_SPAWN_DIR=""

    if [[ -n "${CLAUDE_ENV_FILE:-}" && -f "$CLAUDE_ENV_FILE" && -r "$CLAUDE_ENV_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$CLAUDE_ENV_FILE" 2>/dev/null || true
    fi
}

# Get indicator for context type
# Args: $1 = context ("main" or "worktree")
get_indicator() {
    local context="$1"
    if [[ "$context" == "worktree" ]]; then
        [[ "$USE_ICONS" == "true" ]] && echo -n "$ICON_WORKTREE" || echo -n "$ASCII_WORKTREE"
    else
        [[ "$USE_ICONS" == "true" ]] && echo -n "$ICON_MAIN" || echo -n "$ASCII_MAIN"
    fi
}

# Count local tasks by scanning task-system/tasks/ directory
# Sets: IN_PROGRESS_COUNT, PENDING_COUNT, LOCAL_TASK_IDS (space-separated)
count_local_tasks() {
    IN_PROGRESS_COUNT=0
    PENDING_COUNT=0
    LOCAL_TASK_IDS=""

    local tasks_dir="${CLAUDE_SPAWN_DIR:-}/task-system/tasks"

    # Return zeros if tasks directory doesn't exist
    if [[ ! -d "$tasks_dir" ]]; then
        return 0
    fi

    # Scan each subdirectory in tasks/
    local task_dir
    for task_dir in "$tasks_dir"/*/; do
        # Skip if no directories found (glob didn't match)
        [[ -d "$task_dir" ]] || continue

        # Extract task ID from directory name
        local task_id
        task_id=$(basename "$task_dir")

        # Check if this is a valid task worktree (has task-system/task-{ID}/ folder)
        local task_folder="$task_dir/task-system/task-$task_id"
        if [[ ! -d "$task_folder" ]]; then
            # Malformed task directory - skip it
            continue
        fi

        # Track this task ID for remote filtering
        LOCAL_TASK_IDS="$LOCAL_TASK_IDS $task_id"

        # Check for journal.md to determine status
        if [[ -f "$task_folder/journal.md" ]]; then
            IN_PROGRESS_COUNT=$((IN_PROGRESS_COUNT + 1))
        else
            PENDING_COUNT=$((PENDING_COUNT + 1))
        fi
    done
}

# Count remote task branches that don't have local worktrees
# Sets: REMOTE_COUNT
count_remote_tasks() {
    REMOTE_COUNT=0

    # Need CLAUDE_SPAWN_DIR to determine git context
    local spawn_dir="${CLAUDE_SPAWN_DIR:-}"
    if [[ -z "$spawn_dir" ]]; then
        return 0
    fi

    # Check if spawn dir is a git repository
    if ! git -C "$spawn_dir" rev-parse --git-dir &>/dev/null; then
        return 0
    fi

    # Get remote task branches
    local remote_branches
    remote_branches=$(git -C "$spawn_dir" branch -r 2>/dev/null | grep -E 'origin/task-[0-9]+-' || true)

    # If no remote branches, return 0
    if [[ -z "$remote_branches" ]]; then
        return 0
    fi

    # Count branches that don't have local worktrees
    local branch
    while IFS= read -r branch; do
        # Extract task ID from branch name (e.g., "  origin/task-001-feature" -> "001")
        # Trim leading whitespace and extract ID using parameter expansion
        branch="${branch#"${branch%%[![:space:]]*}"}"  # Trim leading whitespace

        # Extract task ID: remove "origin/task-" prefix, then extract digits before "-"
        local task_id="${branch#origin/task-}"
        task_id="${task_id%%-*}"

        # Skip if we couldn't extract a valid numeric task ID
        [[ ! "$task_id" =~ ^[0-9]+$ ]] && continue

        # Check if this task has a local worktree
        if [[ "$LOCAL_TASK_IDS" != *" $task_id"* ]]; then
            REMOTE_COUNT=$((REMOTE_COUNT + 1))
        fi
    done <<< "$remote_branches"
}

# Count features by status from feature.md files
# Sets: FEATURE_ACTIVE_COUNT, FEATURE_DRAFT_COUNT
count_features_by_status() {
    FEATURE_ACTIVE_COUNT=0
    FEATURE_DRAFT_COUNT=0

    local features_dir="${CLAUDE_SPAWN_DIR:-}/task-system/features"

    # Return zeros if features directory doesn't exist
    if [[ ! -d "$features_dir" ]]; then
        return 0
    fi

    # Scan each feature directory
    local feature_dir
    for feature_dir in "$features_dir"/*/; do
        # Skip if no directories found (glob didn't match)
        [[ -d "$feature_dir" ]] || continue

        local feature_md="$feature_dir/feature.md"

        # Skip if feature.md doesn't exist
        [[ -f "$feature_md" ]] || continue

        # Extract status line (first occurrence of **Status:**)
        local status_line
        status_line=$(grep -m1 '^\*\*Status:\*\*' "$feature_md" 2>/dev/null || true)

        # Skip if no status line found
        [[ -n "$status_line" ]] || continue

        # Extract status value (everything after "**Status:** ")
        local status="${status_line#*\*\*Status:\*\* }"

        # Normalize: trim whitespace and convert to lowercase for comparison
        status=$(echo "$status" | xargs | tr '[:upper:]' '[:lower:]')

        # Categorize status
        case "$status" in
            "in progress")
                FEATURE_ACTIVE_COUNT=$((FEATURE_ACTIVE_COUNT + 1))
                ;;
            "draft"|"planned")
                FEATURE_DRAFT_COUNT=$((FEATURE_DRAFT_COUNT + 1))
                ;;
            # Skip unknown statuses (Complete, Archived, etc.)
            *)
                continue
                ;;
        esac
    done
}

# Parse task.md to extract task information
# Sets: TASK_TITLE, TASK_TYPE, FEATURE_LINK
parse_task_info() {
    TASK_TITLE=""
    TASK_TYPE=""
    FEATURE_LINK=""

    local task_file="${CLAUDE_SPAWN_DIR:-}/task-system/task-${CURRENT_TASK_ID}/task.md"

    # Return if task file doesn't exist
    if [[ ! -f "$task_file" ]]; then
        return 0
    fi

    # Extract task title (first line matching "# Task NNN: Title")
    local title_line
    title_line=$(grep -m1 '^# Task [0-9]*:' "$task_file" 2>/dev/null || true)
    if [[ -n "$title_line" ]]; then
        TASK_TITLE="${title_line#*: }"
    fi

    # Extract task type from "**Type:** value" line
    local type_line
    type_line=$(grep -m1 '^\*\*Type:\*\*' "$task_file" 2>/dev/null || true)
    if [[ -n "$type_line" ]]; then
        TASK_TYPE="${type_line#*\*\*Type:\*\* }"
    fi

    # Extract feature link from "**Feature:** [NNN-name](path)" line
    local feature_line
    feature_line=$(grep -m1 '^\*\*Feature:\*\*' "$task_file" 2>/dev/null || true)
    if [[ -n "$feature_line" ]]; then
        # Extract just the feature ID and name from markdown link
        FEATURE_LINK=$(echo "$feature_line" | sed -n 's/.*\[\([^]]*\)\].*/\1/p')
    fi
}

# Parse feature.md to extract feature name
# Args: $1 = feature ID (e.g., "001-auth")
# Returns: feature name via stdout
get_feature_name() {
    local feature_id="$1"
    local feature_file="${CLAUDE_SPAWN_DIR:-}/task-system/features/${feature_id}/feature.md"

    # If not found and we're in a worktree, try going up to task-system level
    if [[ ! -f "$feature_file" && "${TASK_CONTEXT:-}" == "worktree" ]]; then
        # In worktree: /path/to/main/task-system/tasks/042
        # Features at:  /path/to/main/task-system/features
        # Go up two levels from worktree to task-system, then into features
        feature_file="${CLAUDE_SPAWN_DIR:-}/../../features/${feature_id}/feature.md"
    fi

    if [[ ! -f "$feature_file" ]]; then
        echo -n ""
        return
    fi

    # Extract feature name from "# Feature: Name" line
    local name_line
    name_line=$(grep -m1 '^# Feature:' "$feature_file" 2>/dev/null || true)
    if [[ -n "$name_line" ]]; then
        echo -n "${name_line#*: }"
    else
        echo -n ""
    fi
}

# Get task type icon
# Args: $1 = task type
get_task_type_icon() {
    local task_type="$1"

    if [[ "$USE_ICONS" == "true" ]]; then
        case "$task_type" in
            feature) echo -n "‚ú®" ;;
            bugfix) echo -n "üêõ" ;;
            refactor) echo -n "‚ôªÔ∏è" ;;
            performance) echo -n "‚ö°" ;;
            deployment) echo -n "üöÄ" ;;
            *) echo -n "üìù" ;;
        esac
    else
        case "$task_type" in
            feature) echo -n "[F]" ;;
            bugfix) echo -n "[B]" ;;
            refactor) echo -n "[R]" ;;
            performance) echo -n "[P]" ;;
            deployment) echo -n "[D]" ;;
            *) echo -n "[T]" ;;
        esac
    fi
}

# Format a powerline segment
# Args: $1 = content, $2 = bg_color, $3 = fg_color, $4 = next_bg_color
segment() {
    local content="$1"
    local bg="$2"
    local fg="$3"
    local next_bg="${4:-}"

    # Output: bg + fg + content + reset
    printf "%b%b %s %b" "$bg" "$fg" "$content" "$RESET"

    # Add separator if there's a next background
    if [[ -n "$next_bg" ]]; then
        # Separator with current bg as fg color, next bg as background
        printf "%b%b%s%b" "$next_bg" "$bg" "$SEPARATOR" "$RESET"
    fi
}

# Format origin section
# Returns: origin segment
format_origin_segment() {
    local context="${TASK_CONTEXT:-main}"
    local indicator
    indicator=$(get_indicator "$context")

    local bg_color
    if [[ "$context" == "worktree" ]]; then
        bg_color="$BG_CYAN"
    else
        bg_color="$BG_BLUE"
    fi

    echo -n "$bg_color$FG_WHITE $indicator $RESET"
}

# Format task info section
# Returns: task info segment
format_task_segment() {
    # Parse task information
    parse_task_info

    local content=""

    # Build task info string
    if [[ -n "$TASK_TYPE" ]]; then
        local type_icon
        type_icon=$(get_task_type_icon "$TASK_TYPE")
        content="$type_icon"
    fi

    if [[ -n "$TASK_TITLE" ]]; then
        # Truncate title if too long
        local title="$TASK_TITLE"
        if [[ ${#title} -gt 30 ]]; then
            title="${title:0:27}..."
        fi
        content="$content $title"
    else
        content="$content Task $CURRENT_TASK_ID"
    fi

    # Add feature name if available
    if [[ -n "$FEATURE_LINK" ]]; then
        local feature_name
        feature_name=$(get_feature_name "$FEATURE_LINK")
        if [[ -n "$feature_name" ]]; then
            # Truncate feature name if too long
            if [[ ${#feature_name} -gt 20 ]]; then
                feature_name="${feature_name:0:17}..."
            fi
            content="$content ($feature_name)"
        fi
    fi

    echo -n "$BG_GRAY$FG_WHITE $content $RESET"
}

# Format task counts
# Returns: formatted string with task counts
format_task_counts() {
    local output=""

    if [[ "$USE_ICONS" == "true" ]]; then
        output="$ICON_IN_PROGRESS $IN_PROGRESS_COUNT $ICON_PENDING $PENDING_COUNT $ICON_REMOTE $REMOTE_COUNT"
    else
        output="${ASCII_IN_PROGRESS}${IN_PROGRESS_COUNT} ${ASCII_PENDING}${PENDING_COUNT} ${ASCII_REMOTE}${REMOTE_COUNT}"
    fi

    echo -n "$output"
}

# Format feature counts
# Returns: formatted string with feature counts
format_feature_counts() {
    local output=""

    if [[ "$USE_ICONS" == "true" ]]; then
        output="$ICON_FEATURE_ACTIVE $FEATURE_ACTIVE_COUNT $ICON_FEATURE_DRAFT $FEATURE_DRAFT_COUNT"
    else
        output="${ASCII_FEATURE_ACTIVE}${FEATURE_ACTIVE_COUNT} ${ASCII_FEATURE_DRAFT}${FEATURE_DRAFT_COUNT}"
    fi

    echo -n "$output"
}

# Format counts section (task counts + feature counts)
# Returns: counts segment
format_counts_segment() {
    # Count tasks and features
    count_local_tasks
    count_remote_tasks
    count_features_by_status

    local task_counts
    task_counts=$(format_task_counts)

    local feature_counts
    feature_counts=$(format_feature_counts)

    local content="$task_counts | $feature_counts"

    echo -n "$BG_DARK_GRAY$FG_LIGHT_GRAY $content $RESET"
}

build_output() {
    local output=""
    local segments=()
    local prev_bg=""

    # Collect segments that should be shown
    if [[ "$SHOW_ORIGIN" == "true" ]]; then
        local context="${TASK_CONTEXT:-main}"
        if [[ "$context" == "worktree" ]]; then
            prev_bg="$BG_CYAN"
        else
            prev_bg="$BG_BLUE"
        fi
        segments+=("origin")
    fi

    if [[ "$SHOW_TASK" == "true" && -n "$CURRENT_TASK_ID" ]]; then
        segments+=("task")
    fi

    if [[ "$SHOW_COUNTS" == "true" ]]; then
        segments+=("counts")
    fi

    # Build output with separators
    local segment_count=${#segments[@]}
    local i=0

    for segment_type in "${segments[@]}"; do
        i=$((i + 1))
        local next_bg=""

        # Determine next background color
        if [[ $i -lt $segment_count ]]; then
            local next_segment="${segments[$i]}"
            case "$next_segment" in
                origin)
                    local context="${TASK_CONTEXT:-main}"
                    [[ "$context" == "worktree" ]] && next_bg="$BG_CYAN" || next_bg="$BG_BLUE"
                    ;;
                task) next_bg="$BG_GRAY" ;;
                counts) next_bg="$BG_DARK_GRAY" ;;
            esac
        fi

        # Format segment
        case "$segment_type" in
            origin)
                output+=$(format_origin_segment)
                if [[ -n "$next_bg" ]]; then
                    output+="${next_bg}${prev_bg}${SEPARATOR}${RESET}"
                    prev_bg="$next_bg"
                fi
                ;;
            task)
                output+=$(format_task_segment)
                if [[ -n "$next_bg" ]]; then
                    output+="${next_bg}${BG_GRAY}${SEPARATOR}${RESET}"
                    prev_bg="$next_bg"
                fi
                ;;
            counts)
                output+=$(format_counts_segment)
                ;;
        esac
    done

    printf "%s\n" "$output"
}

main() {
    parse_args "$@"
    load_environment
    build_output
}

main "$@"
